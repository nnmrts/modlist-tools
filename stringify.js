import { stringify as stringifyIni } from "@std/ini";
// @ts-nocheck
import {
	basename, dirname, join
} from "@std/path";

import { counting } from "@radashi-org/radashi";

import {
	game,
	isVanillaMod,
	modlistFilePath,
	modlistOldFilePath,
	modsFolderPath,
	parseOutputModifiedFilePath
} from "./_common/_exports.js";
import { convertTagsToCategory } from "./stringify/_exports.js";

/**
 * @import { Mod } from "./_common/_exports.js";
 */

const {
	mkdir,
	readDir,
	readTextFile,
	remove,
	rename,
	writeTextFile
} = Deno;

const {
	Now
} = Temporal;

const parseOutputModifiedFileContent = await readTextFile(parseOutputModifiedFilePath);

const mods = JSON.parse(parseOutputModifiedFileContent).map(({ files, ...rest }) => rest);

/**
 *
 * @param mods
 * @param ungroupedMods
 * @example
 */
const groupMods = (ungroupedMods) => [
	...Map.groupBy(
		ungroupedMods,
		({ name, tags }) => {
			const category = convertTagsToCategory(tags);

			if (name.includes("BattleMeals")) {
				console.log(category);
			}

			if (category.replaceAll(/\(.*?\)/gu, "").includes(" & ")) {
				return category;
			}

			return category.split(" - ")[0];
		}
	)
]
	.map(([category, modsInCategory]) => [
		category,
		[
			...modsInCategory
				.filter(({ tags }) => {
					const innerCategory = convertTagsToCategory(tags);

					return !innerCategory.includes(" - ") || innerCategory.replaceAll(/\(.*?\)/gu, "").includes(" & ");
				}),
			...groupMods(
				modsInCategory
					.filter(({ tags }) => {
						const innerCategory = convertTagsToCategory(tags);

						return !(!innerCategory.includes(" - ") || innerCategory.replaceAll(/\(.*?\)/gu, "").includes(" & "));
					})
					.map(({ tags, ...rest }) => ({
						...rest,
						tags: tags
							.filter((tag) => tag.includes(" - "))
							.map((tag) => tag.split(" - ").slice(1).join(" - "))
					}))
			)
		]
	])
	.toSorted(([categoryA], [categoryB]) => categoryA.localeCompare(categoryB));

/**
 *
 * @param modTree
 * @param level
 * @param parents
 * @example
 */
const stringifyToModlistMods = (modTree, level = 0, parents = []) => modTree.map(([separator, modsOrTrees]) => [
	`-${parents.map((parent) => `[${parent}]`).join("")}[${separator}]_separator`,
	...modsOrTrees
		.filter((modOrTree) => !Array.isArray(modOrTree))
		.map(({ enabled, name }) => {
			const prefix = isVanillaMod({
				game,
				mod: { name }
			})
				? "*"
				: (
					enabled
						? "+"
						: "-"
				);

			return `${prefix}${name}`;
		}),
	...modsOrTrees
		.filter((modOrTree) => Array.isArray(modOrTree))
		.map((tree) => stringifyToModlistMods([tree], level + 1, [...parents, separator]))
]
	.join("\n"))
	.join("\n");

/**
 *
 * @param mods
 * @example
 */
const stringifyToModlist = (mods) => {
	console.log(mods.find(({ name }) => name.includes("BattleMeals")));

	const tree = groupMods(mods);

	console.log(tree);

	const mainText = stringifyToModlistMods(tree)
		.split("\n")
		.toReversed()
		.join("\n");

	return `# This file was automatically generated by Mod Organizer.\n${mainText}\n`;
};

const stringifiedModlist = stringifyToModlist(mods);

const separators = stringifiedModlist
	.split("\n")
	.filter((line) => line.endsWith("_separator"))
	.map((line) => line.slice(1));

const separatorMetadata = {
	General: {
		lastNexusQuery: "",
		lastNexusUpdate: "",
		category: "-1,",
		color: String.raw`@Variant(\0\0\0\x43\0\xff\xff\0\0\0\0\0\0\0\0)`,
		comments: "",
		converted: false,
		gameName: "Starfield",
		hasCustomURL: false,
		ignoredVersion: "",
		installationFile: "",
		modid: "0",
		newestVersion: "",
		nexusCategory: "0",
		nexusDescription: "",
		nexusFileStatus: "1",
		nexusLastModified: Now.instant().toString({ smallestUnit: "seconds" }),
		notes: "",
		repository: "Nexus",
		tracked: "0",
		url: "",
		validated: false,
		version: ""
	},
	installedFiles: {
		size: "0"
	}
};

for await (const { isDirectory, name } of readDir(modsFolderPath)) {
	if (isDirectory && name.endsWith("_separator")) {
		const separatorFolderPath = join(modsFolderPath, name);

		await remove(separatorFolderPath, { recursive: true });
	}
}

for (const separator of separators) {
	const separatorFolderPath = join(modsFolderPath, separator);

	await mkdir(separatorFolderPath, { recursive: true });

	const separatorMetadataFilePath = join(separatorFolderPath, "meta.ini");

	const separatorMetadataFileContent = stringifyIni(separatorMetadata);

	await writeTextFile(separatorMetadataFilePath, separatorMetadataFileContent);
}

await rename(modlistFilePath, modlistOldFilePath);

await writeTextFile(modlistFilePath, stringifyToModlist(mods));
